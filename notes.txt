Kotlin emphasizes on:
- conciseness
- safety
- pragmatism
- interoperability with Java

In kotlin, you can write functions outside of class, in Java, you can not
but the truth is, the compiler will then deal with boilerplate code and generate the class under the covers for us
these functions are called top level functions because they are not defined in a class

kotlinc compiles .kt files into .class files that are equivalent to the ones that javac produces and that can be read by the JVM
to run kotlin applications, we need the kotlin runtime library which is something similar in nature to the JRE

the JVM looks for the main(...) method signature to find the entry point of a program
everything is a class in kotlin for example Array<String>

Kotlin tries to reduce the amount of code we write
for example, we write println() instead of Systemt.out.println() because kotlin imports from of this stuff from the start
we call this the kotlin standard library
https://kotlinlang.org/api/latest/jvm/stdlib/
it serves the same purpose that the JDK does, it has a bunch of API for you to use

Kotlin is statically typed, meaning that all variable types are known at compile time

kotlin: prefers stuff to be immutable than mutable vs Java, where by default, variables are mutable
    val number3: Int
    number3 = 10
    // number3 = 11 => this will throw the error

    var number4: Int
    number4 = 9
    number4 = 12
    // var: value is mutable

val employee = Employee("lynn smith", 500) => no need for "new" keyword
employee.name = "lynn jones"
// employee.id = 5
// val employee can not be assigned a new Employee instance (val), but that does not mean that its member variables
// can not be changed, in this case, the name can be changed (var) but id (val) can not

Type Aliases
============
StringBuilder stringBuilder...
by going to its definition, we see the following
@SinceKotlin("1.1") public actual typealias StringBuilder = java.lang.StringBuilder
=> this means, that when we use StringBuilder in kotlin, we are actually using the java StringBuilder

Custom Aliases can be declared => but done at file level
declare it: typealias EmployeeSet = Set<Employee>
use it: val employees: EmployeeSet

Some quick diff between Java and Kotlin
---------------------------------------
kotlin does not require semicolons
kotlin has many wrappers around some commonly used Java functions like println and System.out.println
Hard keywords: Java and Kotlin => example: int, double, if...
Soft keywords: Kotlin => soft keywords can be redefined where they are not being used to meet their built-in function,
but it is not considered as a good practice

square brackets can be used to access elements in collection instead of .get()
=> this is done in pursuit of more concise code
concise: giving a lot of information clearly and in a few words; brief but comprehensive

Kotlin has its own String class
for example, in Java length is a method (bla.length()) while in kotlin, it is a property

Equalities
----------
in Java:
== => compares instance references
.equals(...) => override to check for structural equality
in Kotlin:
== => different to the .equals() method
=== => the triple = is what checks for referential equality
same applies for != and !==

NOTE
----
The difference between == and === is that: == converts the variable values to the same type before performing comparison.
This is called type coercion. === does not do any type conversion (coercion) and returns true only if both values and types
are identical for the two variables being compared

Bitwise operators
val x = 0x00110011
val y = 0x10100011

Java => | & ^
kotlin: or and xor

"is" vs "instanceOf"
!is (not is)

Casting and Smart Casting
-------------------------
to cast in Java: (Employee) something
to cast in kotlin: val newEmp = something as Employee
Kotlin does smart casting, for example:
if (something is Employee){
  kotlin treats the variable as if it has been cast
  so here, inside this block of code, no need to cast something as an Employee
}

Request Templates
-----------------
val change = 4.22
println("to show the value of change we use: \$change and its value is $change (ps: $$change shows the $ sign)")
Values of expressions can be substituted as well (you use ${...}):
- println("division = ${x / y}")
- println("employee id = ${employee.id}")

Raw Strings
-----------
triple quoted
no need to escape characters (i.e it includes new line character, can't use \n here)
can be multiline:
"""balbalbalbalbalbalba
lkasdjflkajsdlkfj
asdfasdfasdf"""

the indentation here looks bad, but if we beautify the code, the resulting string will contain the tabs
so we use trimMargin method with a trim margin char of our choosing
bro = """balbalbalbalbalbalba
        *lkasdjflkajsdlkfj
        *asdfasdfasdf""".trimMargin("*")

String templates can also be used inside raw strings

Read Eval and Print Loop: REPL
------------------------------
Go to: Tools -> Kotlin -> REPL
REPL is aware of the declarations in the project
it is like a command line active terminal
you can use it to test some code and evaluate some expressions
it also knows about previous declarations you did in it so,
if you do x = 3 + 4 which results in 7 and reference x later on, you will get the value of 7

Built In Datatypes
------------------
In koltin, everything is a class, no lower case like java
Java: int and Integer
Kotlin: Int

With kotlin, a good practice would be to specify the variable type if it is not being assigned at its declaration
the Datatypes are similar to Java

In Java we can do:
int x = 10;
long xl = x;
=> java widens numbers but kotlin does not
In kotlin we would do:
xl = x.toLong()

Another example:
val myByte: Byte = 111
var myShort: Short
myShort = myByte.toShort()

There is only one exception: Numeric Literals, kotlin will widen them
val anoterInt = 5L => even thought 5 is a small number, but it has the literal L => long
so anotherInt will be of type Long

by default, float points are created as double if the type float is no specified (or use F like L for long)

for Chars, in Java you can do: char x = 65; => the value of x will be the char that maps to 65
in Kotlin, you can not do this. To do use, you use .toChar() => same concept as the others
the Kotlin types compile to Java's primitive types and not the type wrapper classes

Void: in Java a method that returns void actually returns nothing
in koltin, what gets returned is called Unit, Unit is a thing unlike java
Unit => singleton instance

in Koltine there is class called Nothing, which is a subclass of every class
=> use case: function that never returns (has an infinite loop) => this is how we tell the compiler this

Arrays
------
the Array class is a collection class
println(long1[0]) => use array index to get values
you can also use .set and .get

lambda expressions can be used to initialize arrays
val myArr = Array<Int>(16) { i -> i * 2 } // i here is the index

val with arrays: will contain a reference to the array that can not be changed, but contents of the array can be
we can also create mixed type arrays (results in an array on "Any")
when passing arrays to java functions that require primitive arrays: (int[] myArr), you need to use the special Kotlin type arrays
like intArrayOf(...), doubleArrayOf(...)
arrayOf(1,2,3) => the types here are "Int"
intArrayOf(1,2,3) => the types can be passed to java methods that expect array of primitives and not arrays of wrapper classes (in this case "Integer")

When dealing with the general array constructor, if you provide the size, you HAVE to provide the values
when dealing with the primitive array constructors, it will be initialized for you

Null Reference in Kotlin
------------------------
kotlin has the notion of nullable type. We use "?" after the variable type
once a variable is nullable, the operations that can be done on it become restricted
certain string methods for example can no longer be called
to get access to it, we do a null check => smart null check like smart casting
OR we use safe access expression str?.length => short hand for null check

if (bankAccount != null) {
    if (bankAccount.country != null){
        if (bankAccount.country.code != null)
            bankAccount.country.code.doSomething()
    }
}

in kotlin, we can do: bankAccount?.country?.code?.doSomething()

=> if one of them is null, it short-circuits and returns null (the expression evaluates to null)

The Elvis Operator "?:" (cz it looks like elvis's hair when his head is tipped on the side)
it lets us assign a default value if an expression evaluates to null
(conditional chaining)

similar to safe access, we have safe casting
val str5 = something as? String
once we have used safe casting, we have the possibility of getting a null, so now we have to use safe access with str5
if "something" can not be cast into String, the the expression results in a null

The NOT NULL assertion: !!
we use this when we are absolutely sure that a variable can NEVER be null
in this case, if the variable ends up as null, we will actually get a null pointer exception
we get a kotlin.KotlinNullPointerException
NOTE: the exception line number in the stack trace appears to be the line where we made the assertion, for example
1) val str: String? = null
2) val str2: str!!
3) val str3: str2.toUpperCase()
=> the exception line number will be "2"
Bad practice, stringing null assertion operator like the safe access operator, the issue here would that
we will only get a line number and the trace will not tell us which of the null assertions failed

For example, we can not pass a nullable variable to a function that is expecting a non-nullable argument
bad practice: myFun(myVar!!)
good practice: use the let function
str?.let {myFun(it)} which is a shorthand for:
if (str != null){
    myFun(str)
}

== is a safe operator
println(str == myString) // no error here even though str can be null, that is because == is a safe operator

creating arrays of nulls:
    val myArrayOfNulls: Array<Int?> = Array(16) { null }
    val myArrayOfNulls2 = arrayOfNulls<Int>(16)

OOP and Kotlin
==============
Access modifiers
----------------
we have 4:
- public, private and protected: like java
- internal => visible inside the module (if inside a private class, then it would only be visible inside the class), so
we would use internal is the variable is accessible from outside the file

In kotlin, classes can not see private members belonging to inner classes
private (kotlin) -> compiled to package private
internal (kotlin) -> compiled to public

The default visibility in Java is package private, but in kotlin, it is public

In java, the top level is always a class, but in kotlin, we can have variables and functions
If an item at the top level is private, that means it is "file level" private

In Java, if a class is public, its name has to match the file name, i.e there can only be one public class per file
in Kotlin that is not the case, you can have multiple classes per file

OOP
---
// Primary constructor => declared outside the curly braces
class Employee constructor(name: String) {
    val name: String

// init blocks are not constructors, they are used in conjunction with the primary constructor
// primary constructors can not contain code, so you would need to use init blocks (you can have more than one)
    init {
        this.name = name
    }
}

// another way of writing the above - reduction of boilerplate code
class Employee constructor(name: String) {
    val name: String = name
}

// more boilerplate reduction, under the hood, the code gets added
class Employee constructor(val name: String) {
}

// even more boilerplate reduction, remove the "constructor" keyword
class Employee (val name: String) {
}

we would need to add the constructor keyword back if we need to change the visibility of the primary constructor

// SECONDARY CONSTRUCTOR
class Employee(val name: String) {

    var fullTime: Boolean = true

    // 2ndary constructor can not declare members (val or var)
    // also, it must delegate what needs to be delegated to the primary constructor =>" : this(...)"
    constructor(name: String, fullTime: Boolean) : this(name) {
        this.fullTime = fullTime
    }
}

// The kotlin way
class Employee(val name: String, var fullTime: Boolean = true) {...}

PS: primary constructor is not mandatory, simply write the class like you do in Java
PS: default values can also be used in 2ndary constructors

Properties:
-----------
in kotlin, we call member variables and fields: properties
for public properties, we use the dot notation. Under the hood, this is calling the default getters and setters

in kotlin, getters and setters must have the same visibility as their properties
to a private property will have a private getter and a private setter (or ones with less permissive access)
hence it can not be accessed from outside of its class
in Kotlin, we have to think differently: in koltin, it is OK to have public properties

PS: access modifiers can be added in the primary constructor, for example:
class Employee(val name: String, private var fullTime: Boolean = true) {...}

In case we need a custom getter and setter, we will have to declare the properties within the class and not the constructor

in kotlin, if you want a custom set and get, you HAVE to write them directly after the property declaration

    var fullTime = fullTime
        get() {
            println("running the custom get")
            return field // this is called the backing field, this is only generated if we need the value of fullTime
        }
        set(value) {
            println("running the custom set")
            field = value
        }

Constants
---------
val MY_CONTANT = 100 // at the top level of the file
we use val for immutability

PS: the const keyword can be used with koltin:
const val x = 8
can't be used with var, val only: const var x = 8 => compiler shows red

Data Classes
------------
a class that is only meant to store state
properties, setters and getters only

with data classes, we get some nice functions for free
comes with its own toString() function, a custom implementation of the equals() function and a copy() function
=> all of these of course can be overridden
=> any property that is not defined in the primary constructor, will not be taken into account for the methods mentioned above

println(car == car2) // True: data class => by default, it does structural comparison
println(car === car2) // false: different instance

var car4 = car.copy(year = 2016) // copy everything but change value of year property

Condition: there must be a primary constructor and it must contain at least 1 declaration (val or var)
also, anything set in it MUST also be a declaration

they also get: destructuring declaration
data classes also can not be abstract, sealed or inner classes

Functions
---------
// function with block body
fun labelMultiply(x: Int, y: Int, label: String): String {
    return "$label ${x * y}"
}

If all the function is doing is returning the result of an expression, then we can remove more boilerplate code:
// function with an expression body
fun labelMultiply2(x: Int, y: Int, label: String) = "$label ${x * y}"

Void (java) return type: Unit (kotlin)

vararg keyword
--------------
fun printCars(vararg cars: Car) {...}
restriction: we can only have 1 vararg parameter in a function signature
If vararg was not the last parameter in the function signature, then everything that comes after is will need to be
sent while mentioning the parameter name

val numbers = arrayOf(1,2,3) => arrayOf is actually using a vararg

Spread operator: *
spreads an array into a vararg
val manyCars = arrayOf(car, car2, car3)

// We use the spread operator to spread the array
var moreCars = arrayOf(car2, car3)
val lotsOfCars = arrayOf(manyCars, moreCars, car4) => array containing 2 arrays and an car Object
but we just want an array of cars so:
val lotsOfCars = arrayOf(*manyCars, *moreCars, car4)

extension function
------------------
allows us to extend a class with more functions
this does not mean that encapsulations can be broken

// Classic Way
fun upperFirstAndLast(str: String): String {
        val upperFirst = str.substring(0, 1).uppercase() + str.substring(1)
        return upperFirst.substring(0, upperFirst.length - 1) + upperFirst.substring(
            upperFirst.length - 1,
            upperFirst.length
        ).uppercase()
    }

// to Call: upperFirstAndLast("blabla")

// makes it look like the function belongs to the String class
fun String.upperFirstAndLast(): String {
    val upperFirst = this.substring(0, 1).uppercase() + this.substring(1)
    return upperFirst.substring(0, upperFirst.length - 1) + upperFirst.substring(
        upperFirst.length - 1,
        upperFirst.length
    ).uppercase()
}

// to Call: "blabla".upperFirstAndLast()
What we did here is that we preceded the function name with what we call the receiver type
and "blabla" is the receiver Object
=> we can also drop the use of "this":
val upperFirst = this.substring(0, 1).uppercase() + this.substring(1)
val upperFirst = substring(0, 1).uppercase() + substring(1)

Inline Function
---------------
compiled to its body and NOT a function call
mostly used when dealing with lambdas
inline fun myFun(...) {...}

Inheritance
-----------
in kotlin, everything is final and public by default

// we use the keyword open: to make a class non-final
open class Printer {

}

// we call the default primary constructor
class LaserPrinter : Printer() {

}

// we call the default primary constructor
class LaserPrinter2() : Printer() {

}

// we use a secondary constructor and differ to super()
class LaserPrinter3 : Printer {
    constructor(): super()

}

the same rule for open and abstract applies to functions that we are trying to override
because, of course, in kotlin, everything is final by default, for example:

// we use the keyword open: to make a class non-final
open abstract class Printer(val modelName: String) {
    // after adding abstract => we can remove the open keyword: it becomes redundant
    open fun printModel() = println("the model name is: $modelName")

    // declaring an abtract method
    abstract fun bestSellingPrice(): Double
}

class LaserPrinter(modelName: String) : Printer(modelName) {
    override fun printModel() = println("the new output is: $modelName")
    override fun bestSellingPrice(): Double = 129.99
}

Now, in case we want to make a function un-overridable, we have to explicitly use the keyword final
in addition to abstract, the override keyword implicitly includes the keyword open, so once you override something, you are saying it is open
and it can be overriden

NOTE: you can not call a super 2ndary constructor from a subclass, all MUST delegate to the primary constructor.
thus the only way to do such a thing would be if the parent did not have a primary constructor defined

Data classes are closed, they can not be extended, but they can extend other classes (since kotlin 1.1)
in Kotlin 1.1, they became able to also contain classes

Interfaces
----------
interface MyInter {
    val number: Int // can not be initialized here
    fun myString(str: String): String
}

interface MySubInter: MyInter {
    fun mySubString(str: String): String
}

no need to use keyowrds open and abstract here, these are abstract anyway

// We can ofcourse implement multiple interfaces
class SomethingElse: MyClass, MyInter, MyInter2 {
    override val number: Int = 25

    override fun myString(str: String): String {
        TODO("Not yet implemented")
    }

    override fun myString2(str: String): String {
        TODO("Not yet implemented")
    }
}

in interfaces, we can have properties (they do not need to be abtract)
and we can also provide accessors for them that we can override in subinterfaces or classes that implement said interfaces
the property will have to be initialized ofcourse in the class

in order to give our interface property a default value, we use a custom get:

interface MyInter {
    val number: Int // can not be initialized here
        get() {
            return number * 100
            // or return 25 => now we can call this concrete property
            // in this case, there will be no need to override it
        }
    fun myString(str: String): String
}

interface MyInter {
    val number: Int
    val number2: Int
        get() = 25
    val number3: Int
        get() {
            return 25
        }
    fun myString(str: String): String
}

NOTE: interface properties do not have backing fields

Singletons
----------
We use the keyowrd "object" instead of class
has no constructors
object keyword => creates and constructs

fun main(args: Array<String>){
    println(CompComs.getTagLine())
    println(CompComs.getCopyRightLine())
}


object CompComs {
    val currentYear = Year.now().value
    fun getTagLine() = "our company rocks!"
    fun getCopyRightLine() = "blabla \u00A9 $currentYear blabla"
}

=> one single instance is created the 1st time the class is used
NOTE: Singletons can extend other classes or implement interfaces

Companion Objects
-----------------
Static keywords in kotlin do not exist
=> we would use top level (file level) functions for example

class SomeClass {
    private var privateVar = 6
    fun accessPrivateVar(){
        println(privateVar)
    }

// We can think of everything inside the companion object as static
    companion object {
        private var privateVar2 = 7
        fun accessPrivateVar(){
            println(privateVar2)
        }
    }
}

to call the functions then:
SomeClass.accessPrivateVar2() // using the class without instanciating it
SomeClass.Companion.accessPrivateVar2()

companion object bla {... we can also give it a name "bla"
so... SomeClass.bla.accessPrivateVar2() 

Companion objects can be used to access private constructors
thus they can be used to implement the factory pattern

// We make the primary constructor private => note: a primary constructor is not a requirment for this, can be done with 2ndary ones wihout a primary one
class SomeFactoryClass private constructor(val someString: String) {
//    val someString: String
//
//    private constructor(str: String) {
//        someString = str
//    }
//
//    constructor(str: String, lowerCase: Boolean) {
//        if (lowerCase) {
//            someString = str.lowercase()
//        } else {
//            someString = str.uppercase()
//        }
//    }

    companion object {
        fun justAssign(str: String) = SomeFactoryClass(str)

        fun upperOrLowerCase(str: String, lowerCase: Boolean): SomeFactoryClass {
            if (lowerCase) {
                return SomeFactoryClass(str.lowercase())
            } else {
                return SomeFactoryClass(str.uppercase())
            }
        }
    }
}

Anonymous object | Anonymous expressions
----------------------------------------
every time we call it, we have to provide an implementation for the function
also, these implementations have access to the variables around them, like the 2nd call below accessing "var" thisIsMutable and not a "val" (which is final)

fun main(args: Array<String>) {
    wantsSomeInterface(object : SomeInterface {
        override fun mustImplement(num: Int) = "this is from mustImplement my int: ${num * 100}"
    })

    var thisIsMutable = 45

    wantsSomeInterface(object : SomeInterface {
        override fun mustImplement(num: Int): String{
            thisIsMutable++  
            return "this is from mustImplement my int: ${num * 100}"
        }
    })
}


interface SomeInterface {
    fun mustImplement(num: Int): String
}

fun wantsSomeInterface(si: SomeInterface) {
    println("printing from SomeInterface ${si.mustImplement(22)}")
}

we can all have multiple interfaces:
wantsSomeInterface(object : SomeInterface, SomeInterface2, SomeInterface3... etc

Enums
-----
Very similar to Java
enum class Department2(val fullName: String, val numEmployees: Int) {
    HR("hr", 5),
    IT("it", 7),
    ACCOUNTING("acc", 12),
    SALES("sal", 20);

    fun getDepInfo() = "$fullName and $numEmployees"
}

READ MORE HERE: https://www.baeldung.com/kotlin/enum#overview

imports
-------
imports in kotlin do not have to match to directory structure the same way file names do not have to match the class name
for example, at the top of the file, you can have
package bla.blo.bli
while the folder names are bla -> blo -> juju
will still work fine

Recommended Way: do it like java, conserve the directory structure

If we are dealing with another module (not a package), we will need to add the module as dependency from the project's settings
then, we will be able to import from its files

for enums, we actually import an individual enum, but usually, we would want to import the entire class
enums can be aliased, using "as":
import bla.blo.bli.SomeClass as blu

as can be used with functions as well

extension functions have to be imported if we want to use them in other files

Internal Access modifier
------------------------
"internal" access modifier make a top level function for example accessible from any other file in the same module
BUT files in other modules, even if the file with the internal function is being imported, can not access it

Loops, IF, When and Try/Catch
=============================
Loops
-----
The classic Java for loop is not available in Kotlin
in kotlin, we use ranges, and the start and end are inclusive

val range = 1..5
val range = 'a'..'z'
val range = "ABC".."XYZ"

=> any type that is "Comparable" can be used in a range
that is because of the "in" operator which is used by the loop

val backwardsRange = 5.downTo(1) // OK
val backwardsRange2 = 5..1 // backwards rand this way does not work
this translates to 5 <= x <= 1: as a logical statement, this is always false

// another way of reversing a range to go backwards
val reversedRange = range.reversed()
most of these methods can only be used with numerical and char ranges

val rangWithSteps = 3..15
val stepThree = rangWithSteps.step(3) // returns a range
you can write it like this: val rangWithSteps = (3..15).step(3)
or like this: val rangWithSteps4 = 3..15 step 4

// another way of reversing a range to go backwards
val reversedRange = range.reversed()

String ranges do not have an iterator defined on them
val range = "ABC".."XYZ" => can contain values like "CCC" and "CCCCCCCCCCCCCC" (comparison happens one char at a time)

Strings however have iterators defined on them:
val str = "hello"
for (c in str) {
    println(c)
}

// loop with step size
for (num in 1..20 step 4) {
        println(num)
}

// loop backwards with step size
for (num in 20 downTo 15 step 2) {
    println(num)
}

you can use the keyword "until", it excludes the final element in the range

val range = 0..str.length

we can also use !in => not in with strings, numbers and chars

val seasons = arrayOf("spring", "summer", "autumn", "fall")
seasons.forEach { println(it) }
seasons.forEachIndexed { index, value -> println("$index is $value") }
for (index in seasons.indices) {
    println("$index is ${seasons[index]}")
}

for (i in 1..3) {
    println(i)
    jloop@ for (j in 1..4) { // we can give loops a name
        println(j)
        for (k in 1..10) {
            println(k)
            if (k == 7) {
                break; // breaks only the k loop
                // if we want to break as the jloop, we 1st give it a name then
                // break@jloop;
                // also works with continue
            }
        }
    }
}

IF statement
------------
ifs can have a return value

// turnary operator does not exist in kotlin
val z = if (x == 5) 6 else 7

val v = if (x == 5) {
    println(x)
    6
} else {
    println("bla")
    7
}

when the IF returns a value, it is an expression
when it does not, it is a statement

// can also be nested in string templates
println("blabla ${if (x == 5) 6 else 7}")

When
----
x = 600
when (x) {
    100 -> println(100)
    200, 600 -> println(200) // we can have multiple cases
    300 -> println(200)
    else -> println("no match")
}

x = 220
when (x) {
    100 -> println(100)
    in 200..250 -> println("in range") // we can have ranges
    300 -> println(200)
    else -> println("no match")
}

x = 330
val y = 30
when (x) {
    100 -> println(100)
    in 200..250 -> println("in range")
    300 + y -> println(300) // we can also use expressions
    else -> println("no match")
}

// Smart casting in play
when (something) {
    is String -> println(something.uppercase()) // smart casting happening here: type is Any, but compiler knows it is a String because of condition check
    is BigDecimal -> println("big D")
}

we can also have

val z = when (something) {
    is String -> println(something.uppercase()) // smart casting happening here: type is Any, but compiler knows it is a String because of condition check
    is BigDecimal -> println("big D")
    else -> print("bla") // else here is mandatory, z MUST have a value, in this case the return value will be "Unit"
}

we can have retur values:
val z = when (something) {
    is String -> { 
            println(something.uppercase())
            1 // this would be the return value if "something" was a string: return value must allways be the last line
    } 
    is BigDecimal -> println("big D")
    else -> print("bla") // else here is mandatory, z MUST have a value, in this case the return value will be "Unit"
}

When user with enums:
val season = Season.FALL
val str = when (season) {
    Season.FALL -> "it is fall"
    Season.SUMMER -> "it is summer"
    else -> "dunno man" // if all the possible enum values are listed, then the else would not be needed
}

println(str)

"when" can be used as an alternative to if else => used without an input value
when {
    x < y -> do this
    x == y -> dot that
    else -> finish it
}

Try / Catch
-----------

fun getNumber(str: String): Int {
    // like other blocks, the last expression's value can serve as a return value
    return try {
        Integer.parseInt(str) // returns the result of this
    } catch (ex: NumberFormatException) {
        0 // returns zero
    } finally { // like java, always executes
        println("finally!")
    }
}

// nullable return type
fun getNumber2(str: String): Int? {
    // like other blocks, the last expression's value can serve as a return value
    return try {
        Integer.parseInt(str) // returns the result of this
    } catch (ex: NumberFormatException) {
        null
    } finally { // like java, always executes
        println("finally bla!")
    }
}

// re-throw / chain exception
fun getNumber3(str: String): Int {
    // like other blocks, the last expression's value can serve as a return value
    return try {
        Integer.parseInt(str) // returns the result of this
    } catch (ex: NumberFormatException) {
        throw IllegalArgumentException("twas bad bro", ex)
    } finally { // like java, always executes
        println("finally bla!")
    }
}

Use case for "Nothing" type
here, we know the function below, in its current state, that it will return nothing, so we use return type "Nothing"
fun notImplementedYet(something: String): Nothing {
    throw IllegalArgumentException("implement me!")
}

Generics, Collections and Lambda Expressions 
============================================
lambdas
-------
A VERY NICE SUMMARY OF LAMBDA SYNTAX:
https://medium.com/@s.badamestani/lambda-in-kotlin-a6fc055a2c88

val employees = listOf(
    Employee("john", "bla", 2010),
    Employee("Bro", "El Sis", 1080)
)

println(employees.minBy { e -> e.startYear })
println(employees.minBy({ e -> e.startYear }))
println(employees.minBy { e: Employee -> e.startYear })
println(employees.minBy { it.startYear })

you can move a lambda outside of a the () if it is the last parameter in the function call
you can also specify the type of the argument the lambda is taking if needed
When there is only 1 parameter and the compiler can infer the type, we can use "it"

When you use a lambda within a function, it can also access properties declared in the function's body (local ones)
note: the variables must be declared before the lambda of course

fun myFun(){
    var bla = 5 // => this is var, so it is mutable, in Java you can only access final local variables in anonymous classes

    // the run lambda function
    run {
        println(bla)
    }
}

// Function parameters can also be accessed
// but they can not be changed like above: so we can not change the value of "num" for example
fun useParamter(employees: List<Employee>, num: Int) {
    employees.forEach {
        println(it.firstName)
        println(it.startYear)
    }
}

you can access a Member reference in place of a lambda expression when all it does is access a property or call a top level function that does not take any parameters
println(employees.minBy(Employee::startYear )) => here we use (...) instead of {...}

fun topLeve() {
    println("i am top level")
}

run(::topLeve)


Receiver Objects
----------------
the with function
-----------------
takes and instance and a lambda expression
the instance itself no longer needs to be reference inside it

fun countTo100(): String {
    val numbers = StringBuilder()
    for (i in 1..99) {
        numbers.append(i)
        numbers.append(", ")
    }
    numbers.append(100)
    return numbers.toString()
}

fun countTo100WithLambda(): String {
    val numbers = StringBuilder()
    
    return with(numbers) {
        for (i in 1..99) {
            append(i)
            append(", ")
        }
        append(100)
        toString()
    }
}

With converts the instance into a receiver object. Said received object can also be referred to with "this."
we can also do this:
return with(StringBuilder()) {...

fun countTo100WithLambda(): String = with(StringBuilder()) {
                                        for (i in 1..99) {
                                            append(i)
                                            append(", ")
                                        }
                                        append(100)
                                        toString()
                                    }

The apply function works like "with" but it always returns the receiver object

fun countTo100ApplyLambda3(): String =
    StringBuilder().apply() {
        for (i in 1..99) {
            append(i)
            append(", ")
        }
        append(100)
        toString()
    }.toString()

NOTE: also() function works like apply() but you use "it" instead of "this"

returning from lambda
---------------------
PS: inline functions get their point of call replaced with their body, for example:
val numbers = listOf(1, 2, 3, 4, 5)
numbers.each { println(it) }

=> given that each is inlined, then the above translates to:
val numbers = listOf(1, 2, 3, 4, 5)
for (number in numbers)
    println(number)

if you look at the documentation of forEach in intelliJ, it says:
public inline fun <T>...

Examples:

fun findByLastName(employees: List<Employee>, name: String) {
    for (employee in employees) {
        if (employee.lastName == name) {
            println("YES, found")
            return
        }
    }

    println("found none")
}

fun findByLastName2(employees: List<Employee>, name: String) {
    employees.forEach {
        if (it.lastName == name) {
            println("YES, found")
            return // the return here also returns from the function and not the lambda
            // this kind of return works only when function that is taking the lambda is inlined
            // forEach is taking the lambda as an parameter and forEach is inlined
            // such a return is called, non-local returns
        }
    }

    println("found none")
}

in Order to do a local return, we use labels:
fun findByLastNameLocalReturn(employees: List<Employee>, name: String) {
    employees.forEach returnBlock@{
        if (it.lastName == name) {
            println("YES, found")
            return@returnBlock
        }

        println("found none")
    }
}

Labels to access different receiver objects
-------------------------------------------
"some String".apply someString@ {
    "another String".apply {
        println(toLowerCase()) // tagets "another string as receiver object"
        println(this@someString.toUpperCase()) // targets "some string as receiver object"
    }
}

Lists and Sets
--------------
Collections in Kotlin:
public interface Collection <out E>: Iterable<E>
= using out: it is covariant => discussed later
Can not be modified: Read only

Arrays are in the Kotlin package and not in the kotlin.collections package
it is considered a collection but it kinda stands on its own

val strings = listOf("spring", "summer", "fall", "winter")
list is an interface, but what is the Concrete class (i.e a class that we can instantiate)?
class java.util.Arrays$ArrayList => kotlin makes this immutable
kotlin enforces immutability using interface definitions
but if passed to java, then it becomes mutable, bcz in java, it is mutable

val emptyList = emptyList<String>()
class kotlin.collections.EmptyList => here there are no java classes backing it
emptyList.isEmpty() => function to check if list is empty

val notNullList = listOfNotNull("hello", null, "good bye") => nulls get cleaned out
println(notNullList)

val arrayList = arrayListOf(1, 2, 3)
println(arrayList.javaClass) => class java.util.ArrayList: classic java mutable list

val mutableList = mutableListOf<Int>(1, 2, 3)
println(mutableList.javaClass) => also results in a java.util.ArrayList

val list = listOf(*array) // we use the "*" spread operator to unpack an array, else we get a list where the 1st element is an array itself
we can also use: val list2 = array.toList()

with lists you can use set and get Functions (or accessors)
println(mutableList)
println(mutableList.get(1))
mutableList.set(1, 5)
println(mutableList)
println(mutableList.get(1))

you can also use:
.last() => gets last element
.first() => gets 1st element

// returns the list reversed
.reversed() -> creates a new lists, so any changes to the original list is not reflected here
.asReversed() -> list is backed by original list and a view of it is returned. This means
that in case the original list was modified, then the variable that is referencing the reversed list view,
if used again, will reflect the new changes without needing to invoke .asReversed() again

println(stringsList.getOrNull(5))
println(stringsList.getOrElse(5) { it -> it * 10 }) -> in this case, it is not the resulting value (which does not exist anyway)
but the value provided for the index

val intList2 = listOf(1, 5, 6, 2)
intList2.max() => get biggest value (in this case, it is 6)

colorList.zip(stringsList) => creates a list of pairs
[(black, spring), (while, summer), (green, fall)] => if the lists are not equal in size, additional elements get dropped of

pairs are a kotlin element Pair<A, B>

val combinedLists = colorList + stringsList => this wil concatenate the lists together

val noDupsList = colorList.union(stringsList) => filters out duplicates from the resulting list

val noDupColors = colorList.distinct() => we can remove the dups from a list

Some functions apply on the list and some return a new list

val mutableSeasons = stringsList.toMutableList() => we can create a mutable list from an immutable list
mutableSeasons.add("some other season")
println(mutableSeasons)

Maps 
----
val immutableMap: Map<Int, Car> = mapOf(
    1 to Car("blue", "toyota", 2016),
    2 to Car("red", "ford", 1990),
    3 to Car("green", "bmw", 2006),
)

 => "key" to "value"

printing the java class and the value of the above:
class java.util.LinkedHashMap
{1=Car@7a79be86, 2=Car@34ce8af7, 3=Car@b684286}

result will be the same if we use "mutableMapOf(...)"

val hashMap = hashMapOf(
=> class java.util.HashMap

for maps we can use "put()" and "get()"

Destructuring declarations
--------------------------
val pair = Pair(10, "ten")
val value1 = pair.first
val value2 = pair.second

// we destructured or distributed an instance
val (valueA, valueB) = pair

Another Example:
for (entry in mutableMap) {
    println(entry.key)
    println(entry.value)
}

for ((key, value) in mutableMap) {
    println(key)
    println(value1)
}

custom destructuring
--------------------
This requires the implementation of component functions, i.e you do not get it out of the box
keyword: operator in front of "fun"

val car = Car("red", "bmw", 1994)
val (color, model, year) = car

class Car(val color: String, val model: String, val year: Int) {
    operator fun component1() = color

    operator fun component2() = model

    operator fun component3() = year
}

the properties need to be public of course

Exception: data classes
in addition to equals and toString f unctions, they get component function for free

Only properties declared in the primary constructor of a data class get componentN() functions.
Properties defined outside the primary constructor or in the body of the class do not get component functions.

Sets
----
val setInts = setOf(1, 2, 3, 4, 5, -20)
println(setInts)
println(setInts.plus(20))
.plus(...) adds to a set, but in this case the set is immutable, to this will results in a new set containing 20
Same will apply for .minus(...)

val mutableSetInts = mutableSetOf(1, 2, 3, 4 - 10) => in this case, we use mutable set
mutableSetInts.add(30)
mutableSetInts.remove(3)
println(mutableSetInts)

we can also do some other actions on the sets:
mutableSetInts.average()
mutableSetInts.drop(2) => drops the 1st 2 entries

setInts.filter { it % 2 != 0 }
when the predicate is true, the item is added to the resulting set

immutableMap2.filter { it.value.year < 2010 }
"it" here is the map entry (key, value) pair

val add10List: MutableList<Int> = mutableListOf()
=> in this case, you need to specify the type in case you are not providing any initial values

the "map" functions:
val ints = arrayOf(1, 2, 3, 4, 5)
val add10List2 = ints.map { it + 10 }
returns a collection containing an entry for each of the entry in the object it is acting on
=> it returns a list and not a map

immutableMap2.map { it.value.year }
=> we can also apply to the iterable entry in a map

we can chain these of course
immutableMap2.map { it.value.year }
immutableMap2.filter { it.value.model == "ford" }.map { it.value.color }

Check if all/any the items match a condition:
immutableMap2.all { it.value.year > 2014 }
immutableMap2.any { it.value.year > 2014 }

We can also count:
immutableMap2.count { it.value.year > 2014 }

We can get all the values of a map into a list
val cars = immutableMap2.values

returns the 1st item that satisfies this condition
cars.find { it.year > 2014 }

cars.groupBy { it.color }
{blue=[Car@614c5515], red=[Car@1e67b872, Car@3f2a3a5], green=[Car@60addb54]}

immutableMap2.toSortedMap() => sorts by key
cars.sortedBy { it.year } => we can specify when we wana sort with

Sequences
=========
When we multi-chain function calls on collections, each time, an intermediate collection instance is created
what if these collections were huge? (memory/performance concerns)

Sequences are similar to Java Streams
When dealing with collections, the collection is dealt with a whole, then passed on as a whole
with Sequences, each items is enumerated and can be acted-on/evaluated on its own, then passed on to the next step or chained function
(whe applicable of course)
=> that way there is no need to create intermediate collections

Streams or Sequences should only be used with large Collections
Sequence in kotlin are quite efficient
immutableMap2.asSequence().filter { it.value.model == "ford" }.map { it.value.color }
simply add a .asSequence() call

we can perform 2 type of operations on sequences, intermediate and terminal
each intermediate step returns a sequence which is passed to the next step
when done, we want to do a terminal operations and terminate the chain and get something concrete

Sequences are lazily evaluated, meaning that they are not evaluated until a terminal operation takes place
 val myList = listOf("jofe", "john", "jane")
        .asSequence()
        .filter { println(it); it[3] == 'e' }
        .map { println(it); it.uppercase() }
        .toList()

    println(myList)
=> in the example above, nothing gets printed because filter and map are intermediate operations, they return sequences
if we add at the end: .toList() => this returns a list and not a sequence, thus it is considered a terminal operation

The print output will be:
jofe
jofe
john
jane
jane
[JOFE, JANE]
=> notice that each entry in goes through the full pipeline (.filter() it gets printed, then .map() and it gets printed again)
if within the chain, an intermediate operation returns false or skips some entry (like .filter()), the item does not continue down the chain (or pipeline)

using the find() function (terminal op), it will return the moment it matches the 1st time, so the rest of the data within the stream does not get processed

When working with collection instead of sequences, the order of the functions matter
since the resulting collection will be passed

NOTE: When creating chains, take a look at it, and optimize which function to call 1st. it can help reduce processing

Generics
========
fun printCollection(collection: List<String>) {
    for (item in collection) {
        println(item)
    }
}

// <T> => type parameter declaration: In this case, the boundary is "Any?" => nullable Any, since any calss decends from it
// to make this not accept non-nullable types, we do: <T: Any> (no question marks here)
fun <T> genericPrintCollection(collection: List<T>) {
    for (item in collection) {
        println(item)
    }
}

// We can also do extension function
fun <T> List<T>.extendedGenericPrintCollection() {
    for (item in this) {
        println(item)
    }
}

Generic Type: class or interface
Generic function : like the example above "genericPrintCollection"
Parametrized types: when the type parameter is a generic type, for example:
- Bla<List<T>>
- Bla<Blo<T>>
- Bla<N> where N is Blo<T>

// Boundaries: Bounded Types
fun <T : Number> converToNumber(collection: List<T>) {
    for (item in collection) {
        println(item.toInt()) // we need to add a boundary else we can not call .toInt() on item
    }
}

// Boundaries: Multiple Boundaries => when T needs to satisfy multiple conditions
fun <T> appendChars(item1: T, item2: T)
        where T : CharSequence, T : Appendable {
    println(item1.append(item2))
}
IMPORTANT: We can have multiple interfaces as conditions, but only 1 class

// Boundaries: Bounded Types can be nullable
fun <T : Number?> converToNumber(collection: List<T>) {
    for (item in collection) {
        println(item?.toInt())
    }
}
IMPORTANT the collection itself being passed does not have to have null entries in this case, but it can have them
the collection itself, when declared to accept nulls, for example: List<Short?>

Type Erasure
------------
At compile time, generic info is erased.
Generics are there to help us type less only, but the generated application will not have this information

In java
List<String> strings = new ArrayList<>();
strings.add("hello");

// We can not do the bellow, the JVM will not have this information
// boolean b = strings instanceof List<String>;
// But we can do:
boolean b = strings instanceof List;

Th JVM knows if a collection is a collection but can not know what type it has

in kotlin:
val strings = listOf("1", "2", "bla")
if (strings is List<String>) {
    println("strings is a List<String>")
}
the above works, probably because the compiler at compile time knows that this check always resolves to true
to the byte code of the "if" statement does not get generated

val strings = listOf("1", "2", "bla")
if (strings is List<String>) {
    println("strings is a List<String>")
}

val list: List<Any> = listOf("str1", "str2")
// The bellow shows an error: can not check for instance of erased type
// if (list is List<String>) {
//     println("list is a List<String>")
// }

// the below is like Java, it works
if (list is List) {
    println("list is a List")
}

var listAny: Any = listOf("str1", "str2")
// The below does not work, in Kotlin, you must always specify the type
// if (listAny is List) {
//     println("list is a List")
// }
// so we use "*" => star projection syntax, it sort of acts like a wild card
if (listAny is List<*>) {
    println("listAny is a List, thank you star projection")
}

// as operator can be used for casting
// of course here, smart casting is happening: listAny (Any) is known to be a List of something
if (listAny is List<*>) { // here we are checking that listAny is a list of anything
    println("listAny contains strings")
    val strList = listAny as List<String>
    println(strList.get(1).replace("str", "string"))
}

// thus, given the above, the below code triggers a java.lang.ClassCastException
listAny = listOf(1, 2, 3)
if (listAny is List<*>) { // here we are checking that listAny is a list of anything
    println("listAny contains strings")
    val strList = listAny as List<String>
    println(strList.get(1).replace("str", "string"))
}

NOTE: if we check the compiler messages (Problems tab), it will tell us that it has there is an unchecked case from Any to List<String>

Reified parameters
------------------
reification is a kotlin feature
reified infline functions prevent the generic type from being erased at runtime
thus we will be able to check on it, using if() for example:
if (element is T) {...}

inline fun <reified T> getElementsOfType(list: List<Any>): List<T> {
    var newList: MutableList<T> = mutableListOf()
    for (element in list) {
        if (element is T) {
            newList.add(element)
        }
    }

    return newList
}

ONLY use reification if you need to check a type
you can not use reification with non inline functions, classes, properties... etc
you can not use T to create a new instance


Variance
--------
covariance 
----------

List is class
List<String> is a Type
List<Number> is a Type
List<Int> is a Type, it is Sub-Type of List<Number>
They are not sub-classes as we are not extending anything here
(same goes for super-type)

one wrinkle to note here are nullable types, they are a wider type than non-nullable types
meaning that if we have a nullable type, we can store non-nullable types in it, but not the inverse

fun main(args: Array<String>) {
    val shortList: List<Short> = listOf(1, 2, 3, 4, 5)
    convertToInt(shortList)

    val mutableShortList: MutableList<Short> = mutableListOf(1, 2, 3, 4, 5)
    mutableConvertToInt(mutableShortList) => this will show an error
}

fun convertToInt(collection: List<Number>) {
    for (num in collection) {
        println(num.toInt())
    }
}

fun mutableConvertToInt(collection: MutableList<Number>) {
    for (num in collection) {
        println(num.toInt())
    }
}

we are able to do this with immutable lists. when we want to pass a List<Short> to a List<Number>, with the later being a supertype of the former
and we want this subtyping to be preserved when dealing with generics, we have to declare the type as covariant

thus, an immutable collection is covariant and mutable list is not

// Example on variance
fun waterGardern(garden: Garden<Flower>) {}

fun tendGarden(roserGarden: Garden<Rose>) {
    waterGardern(roserGarden)
    // the above gives a Type mismatch error
    // Required: Garden<Flower>
    // Found: Garden<Rose>
    // this happens because the garden class is invariant
    // we need to make it covariant: so we add the keyword out to class Garden<T : Flower> {}

}

open class Flower {}

class Rose : Flower() {}

class Daisy : Flower() {}

// a covariant comes with restrictions (like immutable classes)
// we can only use a covariant class in the "out" position
// function parameters are "in" position
// function return type are "out" position
class Garden<out T : Flower> {
    val listOfFlowers: List<T> = listOf()

    fun pickFlower(i: Int): T {
        return listOfFlowers.get(i)
    }
    // you can write the above as fun pickFlower(i: Int): T = listOfFlowers[i]

    // the below Type parameter T is declared as 'out' but occurs in 'in' position in type T
    // these concern member function, so passing a rose garden as a parameter to tendGarden(...) is OK
    // because there is nothing in it that affects the list of flowers
    // fun plantFlower(flower: T) {}
    // So why the restriction?
    // Because: nothing stops calling the plantFlower function with a "daisy" when we have a "rose" garden
}

Example (following up on the above):
val mutableShortList: MutableList<Short> = mutableListOf(1, 2, 3, 4, 5)
mutableConvertToInt(mutableShortList) => this will show an error BUT... (check below)
fun mutableConvertToInt(collection: MutableList<Number>) {
    for (num in collection) {
        println(num.toInt())
    }
    collection.add(25) => here, this will no get underlined in red, it will not show an error
    but if you notice, we would literally be adding a integer to a list of Shorts since the subtyping is preserved
    that is why List does not have an add() function, because then, it opens it up for these kind of shenanigans
}

If you check the mutable list vs list class, you will notice that the later has the out keyword

you can use the type in the "in" position as such:
fun myFun(element: @UnsafeVariance T): SomeReturnType {...} only if myFun changes nothing about the instance's data,
but you have to be ABSOLUTELY SURE (like the !! operator)

NOTE: 
constructor parameters do not have in and out positions, they are called with an instance is created
Also, with "out", we have to use val and not var
with var, kotlin will generate a setter, which means a "in" position
private functions and properties do not have in and out positions also; not available to the outside world
so "private var" would work

do not confuse passing a rose garden to a method that takes a rose garden (subtype) vs one that takes a flower garden
functions declared as part of the class usually do not face this issue because of type erasure

+++++++++++
covariance: we want subtype to be preserved => we are looking down the Inheritance tree
contravariance: we want supertype to be preserved => we are looking up the Inheritance tree

Flower -> Rose
Flower -> Tulip
Vs.
Flower <- Rose => as if saying, Rose is now the supertype of Flower
Flower <- Tulip => as if saying, Tulip is now the supertype of Flower

but the proper way to think about is Rose and anything above it, so in the example above
tulip is not above rose
+++++++++++++++

contravariance
--------------
contravariance appear in the "in" position
contravariance will also come with its own limitations, we can not read from them, on write
i.e "T" can only be used as input but not as a return type for a function for example
Sinc we can now mutate our instance, if we could return type T, then tis will not garentee that we will get the type we want
because we can return any flower from the garden no matter what it is, because we are returning the parent class Flower

it is ok to treat a rose like a flower
but it is not ok to treat a flower like a rose (because we do not know what type of flower it is)
i.e if a function returns a super type, we would be casting into a subtype (contra) => BAD
val rose: Rose = rosegarden.pickFlower() => this method returns a flower and not a rose

fun main(args: Array<String>) {
    // making this an anonymous object with keyword "object"
    val roseTender = object : FlowerCare<Rose2> {
        override fun prune(flower: Rose2) {
            println("I am pruning a rose")
        }
    }

    val roseGarden = Garden2<Rose2>(listOf(Rose2(), Rose2()), roseTender)
    roseGarden.tendFlower(0)

    val daffodilTender = object : FlowerCare<Daffodil> {
        override fun prune(flower: Daffodil) {
            println("I am pruning a daffodil")
        }
    }

    val daffodilGarden = Garden2<Daffodil>(listOf(Daffodil(), Daffodil(), Daffodil()), daffodilTender)
    daffodilGarden.tendFlower(2)

    val flowerTender = object : FlowerCare<Flower2> {
        override fun prune(flower: Flower2) {
            println("I am pruning a Flower")
        }
    }

    // even with the above, we still can not do:
    // val daffodilGarden2 = Garden2<Daffodil>(listOf(Daffodil(), Daffodil(), Daffodil()), flowerTender)
    // we will geta type mismatch error
    // after adding in to interface FlowerCare<in T> {...} below, now we can do this
    val daffodilGarden2 = Garden2<Daffodil>(listOf(Daffodil(), Daffodil(), Daffodil()), flowerTender)
    // now we can reduce repetition and remove the flower and daffodil tender
}


class Garden2<T : Flower2>(val flowers: List<T>, val flowerCare: FlowerCare<T>) {
    fun pickFlower(i: Int) = flowers[i]
    fun tendFlower(i: Int) {
        flowerCare.prune(flowers[i])
    }
}

open class Flower2 {}

class Rose2 : Flower2() {}

class Daffodil : Flower2() {}

interface FlowerCare<in T> {
    fun prune(flower: T) // in position
    // fun pick(i: Int): T - out position
}

All the examples above for variance are known as "Declaration Site Variance" because we are doing it when we declare a class or an interface
In Java we do not have "Declaration Site Variance", we only have "Use Site Variance"
When we say Declaration site, we are usually referring to a class or interface

NOTE: in general, generics types are invariant

Use Site Variance
-----------------
fun main(args: Array<String>) {
    val cars1 = mutableListOf(Car2(), Car2())
    val cars2: MutableList<Car2> = mutableListOf()
    copyCars(cars1, cars2)

    val fords1 = mutableListOf(Ford(), Ford())
    val fords2: MutableList<Ford> = mutableListOf()
    // copyCars(fords1, fords2): this gives errors, it wants cars, so make the method generic to relax or widen the invariant typing
    copyCars(fords1, fords2)
    // copyCars(fords1, cars2): this gives an error because T has to be the same
    val cars3: MutableList<Car2> = mutableListOf(Ford(), Ford()) // this works even though the above does not
    // so how can we fix the copyCars(fords1, cars2) -> looking at the function, we do not modify the source, and we do not read from the destination
    copyCars(fords1, cars2) // we add out to the source => now it works, this is what we call Use-Site covariance
    // because we are changing the class, just some independent function that makes use of said classes
    // this is also called type projection
    // this helps when dealing with 3 party libs, and we want to write functions that use them
    // PS: use site variance in Kotlin is equivalent to wilde cards in Java
    // PS: for the copyCars method, we can also put "in" with the destination variable

}

fun <T : Car2> copyCars(source: MutableList<out T>, destination: MutableList<T>) {
    for (car in source) {
        destination.add(car)
    }
}

open class Car2 {}

class Toyota : Car2() {}

class Ford : Car2() {}

File / IO
=========
Kotlin does not have its own IO classes
it uses the ones that comes with Java

REFER TO FOLLOWING LINK FOR THE FULL DOCS
Kotlin added extension function so that the code can be written in a kotlin way
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/#extensions-for-external-classes

By default, the char set is UTF-8, but we can pass a new one as a parameter to these Functions

Make is a habit of checking the function definition: "right click -> declaration (IDE)"
readLines() for example => it tells you not to use for large files

Most function close the reader, but some will tell you (in their docs in the IDE) that it is your responsibility to close the reader

NOTE: for binary files, the length - generally 2 bytes long - (the weird characters that show up) of a binary string is written in front of it so we can know what it is when parsing

File("testfile.txt").reader()
// Equivalent to:
// new InputStreamReader(new FileStreamReader(new File("testfile.txt)), "UTF-8")

val lines = File("testfile.txt").reader().readLines()
lines.forEach{println(it)}

val reader = File("testfile.txt").reader()
val linesAsString = reader.readText()
println(linesAsString)
reader.close()

// .use{...} for example closes the reader whether an exception is thrown or not
// .use{...} require calling with an object that implement auto-closable
// we can use .bufferedReader instead of reader
val moreLines = File("testfile.txt").reader().use { it.readText() }
println(moreLines)
// we also have a readText() extension function for the File class directly, and this one will close the file
// PS: the "use" and its sister functions are similar to Java's try with resources, there is no direct try-with-resources in Kotlin

File("testfile.txt").reader().forEachLine { println(it) }

// useLines -> produces a sequence, so we need to terminate it (i.e something that does not return a sequence )
File("testfile.txt").reader().useLines { it.forEach { println(it) } }

// Binary Files
val bi = DataInputStream(FileInputStream("testfile.bin"))
var si: String

try {
    while (true) {
        si = bi.readUTF()
        println(si)
    }
} catch (e: EOFException){

}

// walking the file tree
// the walk functions return a sequence of files
File(".").walkTopDown().forEach { println(it) }
File(".").walkBottomUp().forEach { println(it) }

println("-------------")
File(".").walkTopDown()
    .filter { it.name.endsWith(".kt") }
    .forEach { println(it) }


Kotlin Java interoperability
============================
When creating an instance from a java class, you simply import it and then write it kotlin style without the "new" keyword

Nullability
-----------
@Nullable and @NotNull => documentation only: they are not enforced (written in the Java file)
kotlin detects these and maps the objects or properties to kotlin nullable or not nullable versions of them (how the compiler it is going to treat it)
we can set a property to null, we do not get a compiler error, but when we run we get the error (runtime error)

public void setColor(@NotNull String color) {
    this.color = color;
}

public void setColor(@Nullable String color) {
    this.color = color;
}

default type for a java type (property coming from java) is the nullable type
var model = JavaCar.model => model knows it is being assigned a value from java, hence it is implicitly declared as a nullable type
if we explicitly declare model as a nullable kotlin type (var mode: String?), we can no longer do: println(model.javaClass), since model can now be null (now directly known to the kotlin compiler)
NOTE: you can also explicitly declare the kotlin property as non-nullable if you are getting its value from java code

in case we do not specify the Nullability in java, then the variables that are created are called platform type
this occurs when mixing kotlin with another language

in kotlin we can not declare platform types, it is either known and nullable or known and not-nullable (known meaning: String, Int... etc)

when we see an error message with variable name and an "!" mark, this means that we are dealing with a platform variable

we can do "car.model" or "car.model" = "green" only if the field in java is private and has a getter and a setter (in kotlin, we have them by default)
in java, they need to be defined explicitly
if the field in java is public, then we can do it normally


wild cards
----------
wild cards in java that extend some class will be converted to covariant kotlin (out)
wild cards in java that have super some class will be converted to covariant kotlin (in)

exceptions
----------
if we call a java method that throws and exception, we do not need to handle the exception
because kotlin does not distinguish between checked and unchecked exceptions

varargs
-------
public void variableMethod(int num, String... strings) {
    for (String str: strings){
        System.out.println(str);
    }
}

car.variableMethod(5, "hello", "bye")
var strings = arrayOf("hell", "bye")
// car.variableMethod(6, strings) => can't do this, even though in Java we can and even though this is taking an array under the covers
// we have to use the spread operator
car.variableMethod(6, *strings)

Java method returns: void => Unit in kotlin
no primitive types => so when passing ints and doubles array to java methods... from kotlin to java, you need to use the special array: intArrayOf(....) etc
(or convert the arrayOf() using .toIntArray() for example)

When dealing with java Type: "Object" => in kotlin, it becomes "Any"
=> in kotlin, "Any" does not have clone, wait or notify methods
so if we want to call them, we should cast to java.lang.Object from the kotlin code

Java: .getClass() => in kotlin, we just do .javaClass

Static method or field
----------------------
in kotlin, they become companion objects

SAM conversions
---------------
Single Abstract Method
when a java interface has a single abstract method, we can use a lambda expression rather than an anonymous instance (as of Java 8 that is)
Runnable interface in a SAM interface (has 1 method: run())

Java Example:
    public void demoMethod() {
//        constructing a thread
//        new Thread(new Runnable() {
//            @Override
//            public void run() {
//                System.out.println("i am in a thread");
//            }
//        }).start();

        // same as above but using a lambda
        new Thread(() -> System.out.println("i am in a thread")).start();
    }

Kotlin Example:
In Java, the code is:
public static void demoMethod2(Runnable r) {
    new Thread(r).start();
}

calling it from kotlin:
Car.demoMethod2({ println("i am in a thread") })

of course, the function signature has to match whatever this interface is expecting

Calling kotlin from Java
------------------------
under the covers, the compiler will generate a static class for all the top level items
import static learn.kotlin.CarKt.topLevel; (file is called Car.kt)
topLevel();

Or:
import learn.kotlin.CarKt
CarKt.topLevel();

what if we called the kotlin class: "CarKt" instead of "Car"?
this will cause a conflict, but we can change the the name of the generate file using:
@file:JvmName("StaticCar") => you put this at the very top of the file, before everything
the import name then changes:
import learn.kotlin.StaticCar

For extension functions,
we can not simply do a .MyFun on the object, we will have to use it using the file/class name:
if we had:
fun String.print() = println(this) => this prints the string object itself
we have to do:
StaticCar.print("blabl blabla")

when instantiating a kotlin object from java, it has to be done the class way:
Car car = new Car("bla", "bli")
the getters and setters will be automatically created if the class was defined in kotlin unless:
- we used val instead of var => we only get a getter
- private var

class Car (color:String, val model: String){
    private color: String = color
        set(value) {
            field = "always green"
        }
}

so in java, we will automatically get: car.getModel() => the IDE only gives us this option

when dealing with boolean:
the getter will be called: isMyBool() instead of getMyBool()

PS: for variables with multiple words, camel casing is preserved

if we want java to access a property without going through the getter and setter:
we use the annotation: @JvmField
class Car (color:String, @JvmField val model: String){...}
here, we can now do "car.model" from java

@JvmField has restrictions, can not be used with:
- private properties
- property that overrides another property or one that can be overridden
- constant property (when the keyword const is explicitly used in kotlin)

how to access functions withing companion objects?
we must use the @JvmStatic annotation: we put this in the kotlin file
Given: 
class Car (val color:String, val model: String){
    companion object {
        fun carComp () {
            println("i am comp obj of car")
        }
    }
}

doing it like this accesses the method through the instance generated by the compiler:
Car.Companion.carComp();

So... we do: @JvmStatic fun carComp () {...}
then we can do: Car.carComp() => static call

the above is clearer when dealing with singletons:
Kotlin:
object SingletonObject {
    fun myFun() = println("bla")
}

Java:
SingletonObject.INSTANCE.myFun();
but this does no look java like, so we do:
@JvmStatic fun myFun() = println("bla")
then we can do:
SingletonObject.myFun();

For static properties in the companion object, we also use @JvmField to make them accessible from Java

const properties in the companion object are immediately turned to static and does not need to be annotated
the same applies for late initialized properties

in the case below, the kotlin fun is expecting a non-null value, but we can still pass it, we get a runtime IllegalArgumentException
// kotlin
fun printMe(text: String){
    println("I do not expect a null value: $text")
}
// java
car.printMe(null);

in kotlin, we do not need to declare that a function throws an exception while in Java we do
so if a fun in kotlin throws one, we can call the function in Java and it will not ask us to put a try/catch
because their is nothing in the compiled code that tells us an exception can be thrown
so, we annotate the method with @Throws(Exception:class) // you can be more specific about the exception class
@Throws(IOException::class)
fun doIO() {
    throw IOException()
}

with kotlin, we can have functions accept default parameter values
when the kotlin compiler compiles the code, it generates 1 version for Java, which is the one without default parameter values
so we annotate: @JvmOverloads
and now we get both versions of the function
@JvmOverloads fun defaultArgs(str: String, num: Int = 25){}

PS: when calling kotlin from java, if using non-nullable types, then kotlin will throw an IllegalArgumentException if null is passed without having to add @Throws(IllegalArgumentException::class) for example